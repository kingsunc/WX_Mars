// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __ACCESSSERVICE_H_
#define __ACCESSSERVICE_H_

#include <map>
#include <string>
#include <vector>
#include "tars\Tars.h"
#include "tars\msg_tars.h"

using namespace std;

namespace MessageService
{
    enum CONNECT_RESULT
    {
        CONNECT_RESULT_SUCCESS = 0,
        CONNECT_RESULT_ERROR_PROTOCOL = 81,
        CONNECT_RESULT_ERROR_INDICATE = 82,
        CONNECT_RESULT_SERVICE_UNAVAILABLE = 83,
        CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD = 84,
        CONNECT_RESULT_KICKOUT = 85,
        CONNECT_RESULT_OTHER = 86,
    };
    inline string etos(const CONNECT_RESULT & e)
    {
        switch(e)
        {
            case CONNECT_RESULT_SUCCESS: return "CONNECT_RESULT_SUCCESS";
            case CONNECT_RESULT_ERROR_PROTOCOL: return "CONNECT_RESULT_ERROR_PROTOCOL";
            case CONNECT_RESULT_ERROR_INDICATE: return "CONNECT_RESULT_ERROR_INDICATE";
            case CONNECT_RESULT_SERVICE_UNAVAILABLE: return "CONNECT_RESULT_SERVICE_UNAVAILABLE";
            case CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD: return "CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD";
            case CONNECT_RESULT_KICKOUT: return "CONNECT_RESULT_KICKOUT";
            case CONNECT_RESULT_OTHER: return "CONNECT_RESULT_OTHER";
            default: return "";
        }
    }
    inline int stoe(const string & s, CONNECT_RESULT & e)
    {
        if(s == "CONNECT_RESULT_SUCCESS")  { e=CONNECT_RESULT_SUCCESS; return 0;}
        if(s == "CONNECT_RESULT_ERROR_PROTOCOL")  { e=CONNECT_RESULT_ERROR_PROTOCOL; return 0;}
        if(s == "CONNECT_RESULT_ERROR_INDICATE")  { e=CONNECT_RESULT_ERROR_INDICATE; return 0;}
        if(s == "CONNECT_RESULT_SERVICE_UNAVAILABLE")  { e=CONNECT_RESULT_SERVICE_UNAVAILABLE; return 0;}
        if(s == "CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD")  { e=CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD; return 0;}
        if(s == "CONNECT_RESULT_KICKOUT")  { e=CONNECT_RESULT_KICKOUT; return 0;}
        if(s == "CONNECT_RESULT_OTHER")  { e=CONNECT_RESULT_OTHER; return 0;}

        return -1;
    }

    enum KICKOUT_RESULT
    {
        KICKOUT_RESULT_REPEAT = 80,
        KICKOUT_RESULT_TOKEN_TIMEOUT = 81,
    };
    inline string etos(const KICKOUT_RESULT & e)
    {
        switch(e)
        {
            case KICKOUT_RESULT_REPEAT: return "KICKOUT_RESULT_REPEAT";
            case KICKOUT_RESULT_TOKEN_TIMEOUT: return "KICKOUT_RESULT_TOKEN_TIMEOUT";
            default: return "";
        }
    }
    inline int stoe(const string & s, KICKOUT_RESULT & e)
    {
        if(s == "KICKOUT_RESULT_REPEAT")  { e=KICKOUT_RESULT_REPEAT; return 0;}
        if(s == "KICKOUT_RESULT_TOKEN_TIMEOUT")  { e=KICKOUT_RESULT_TOKEN_TIMEOUT; return 0;}

        return -1;
    }

    struct LoginReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.LoginReq";
        }
        static string MD5()
        {
            return "f608f7c81a12477dc352fbb6402712e3";
        }
        LoginReq()
        :appId(""),userId(""),userName(""),token(""),deviceType(0),deviceToken("")
        {
        }
        void resetDefautlt()
        {
            appId = "";
            userId = "";
            userName = "";
            token = "";
            deviceType = 0;
            deviceToken = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(appId, 0);
            _os.write(userId, 1);
            if (userName != "")
            {
                _os.write(userName, 2);
            }
            _os.write(token, 3);
            _os.write(deviceType, 4);
            _os.write(deviceToken, 5);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(appId, 0, true);
            _is.read(userId, 1, true);
            _is.read(userName, 2, false);
            _is.read(token, 3, true);
            _is.read(deviceType, 4, true);
            _is.read(deviceToken, 5, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(appId,"appId");
            _ds.display(userId,"userId");
            _ds.display(userName,"userName");
            _ds.display(token,"token");
            _ds.display(deviceType,"deviceType");
            _ds.display(deviceToken,"deviceToken");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(appId, true);
            _ds.displaySimple(userId, true);
            _ds.displaySimple(userName, true);
            _ds.displaySimple(token, true);
            _ds.displaySimple(deviceType, true);
            _ds.displaySimple(deviceToken, false);
            return _os;
        }
    public:
        std::string appId;
        std::string userId;
        std::string userName;
        std::string token;
        tars::Short deviceType;
        std::string deviceToken;
    };
    inline bool operator==(const LoginReq&l, const LoginReq&r)
    {
        return l.appId == r.appId && l.userId == r.userId && l.userName == r.userName && l.token == r.token && l.deviceType == r.deviceType && l.deviceToken == r.deviceToken;
    }
    inline bool operator!=(const LoginReq&l, const LoginReq&r)
    {
        return !(l == r);
    }

    struct LoginResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.LoginResp";
        }
        static string MD5()
        {
            return "f1833e406b1a8d8d08d96538c1f9ea2d";
        }
        LoginResp()
        :code(MessageService::CONNECT_RESULT_SUCCESS),info(""),server_timeout(20)
        {
        }
        void resetDefautlt()
        {
            info = "";
            server_timeout = 20;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)code, 0);
            if (info != "")
            {
                _os.write(info, 1);
            }
            if (server_timeout != 20)
            {
                _os.write(server_timeout, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = MessageService::CONNECT_RESULT_SUCCESS;
            _is.read(eTemp0, 0, true);
            code = (MessageService::CONNECT_RESULT)eTemp0;
            _is.read(info, 1, false);
            _is.read(server_timeout, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)code,"code");
            _ds.display(info,"info");
            _ds.display(server_timeout,"server_timeout");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)code, true);
            _ds.displaySimple(info, true);
            _ds.displaySimple(server_timeout, false);
            return _os;
        }
    public:
        MessageService::CONNECT_RESULT code;
        std::string info;
        tars::Int32 server_timeout;
    };
    inline bool operator==(const LoginResp&l, const LoginResp&r)
    {
        return l.code == r.code && l.info == r.info && l.server_timeout == r.server_timeout;
    }
    inline bool operator!=(const LoginResp&l, const LoginResp&r)
    {
        return !(l == r);
    }

    struct Kickout : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.Kickout";
        }
        static string MD5()
        {
            return "83f3e4405d6cc63fbbdd7c84a5aaaf8b";
        }
        Kickout()
        :code(MessageService::KICKOUT_RESULT_REPEAT)
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)code, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = MessageService::KICKOUT_RESULT_REPEAT;
            _is.read(eTemp0, 0, true);
            code = (MessageService::KICKOUT_RESULT)eTemp0;
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)code,"code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)code, false);
            return _os;
        }
    public:
        MessageService::KICKOUT_RESULT code;
    };
    inline bool operator==(const Kickout&l, const Kickout&r)
    {
        return l.code == r.code;
    }
    inline bool operator!=(const Kickout&l, const Kickout&r)
    {
        return !(l == r);
    }

    struct MsgReceipt : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.MsgReceipt";
        }
        static string MD5()
        {
            return "baf395bb7913545ddc1152c099ae23b9";
        }
        MsgReceipt()
        :seqId(0),receiptCount(0)
        {
        }
        void resetDefautlt()
        {
            seqId = 0;
            receiptCount = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(queue, 0);
            _os.write(seqId, 1);
            if (receiptCount != 0)
            {
                _os.write(receiptCount, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(queue, 0, true);
            _is.read(seqId, 1, true);
            _is.read(receiptCount, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(queue,"queue");
            _ds.display(seqId,"seqId");
            _ds.display(receiptCount,"receiptCount");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(queue, true);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(receiptCount, false);
            return _os;
        }
    public:
        MessageService::MessageSet queue;
        tars::Int64 seqId;
        tars::Int32 receiptCount;
    };
    inline bool operator==(const MsgReceipt&l, const MsgReceipt&r)
    {
        return l.queue == r.queue && l.seqId == r.seqId && l.receiptCount == r.receiptCount;
    }
    inline bool operator!=(const MsgReceipt&l, const MsgReceipt&r)
    {
        return !(l == r);
    }

    struct PresenceReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.PresenceReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        PresenceReq()
        :userId("")
        {
        }
        void resetDefautlt()
        {
            userId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(userId, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(userId, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(userId,"userId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(userId, false);
            return _os;
        }
    public:
        std::string userId;
    };
    inline bool operator==(const PresenceReq&l, const PresenceReq&r)
    {
        return l.userId == r.userId;
    }
    inline bool operator!=(const PresenceReq&l, const PresenceReq&r)
    {
        return !(l == r);
    }

    struct MonitorResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.MonitorResp";
        }
        static string MD5()
        {
            return "8106794cf632e731bac2d2c7b3d02723";
        }
        MonitorResp()
        :broker_id(""),user_online(0),send_msgs(0),recv_msgs(0)
        {
        }
        void resetDefautlt()
        {
            broker_id = "";
            user_online = 0;
            send_msgs = 0;
            recv_msgs = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (broker_id != "")
            {
                _os.write(broker_id, 0);
            }
            if (user_online != 0)
            {
                _os.write(user_online, 1);
            }
            if (send_msgs != 0)
            {
                _os.write(send_msgs, 2);
            }
            if (recv_msgs != 0)
            {
                _os.write(recv_msgs, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(broker_id, 0, false);
            _is.read(user_online, 1, false);
            _is.read(send_msgs, 2, false);
            _is.read(recv_msgs, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(broker_id,"broker_id");
            _ds.display(user_online,"user_online");
            _ds.display(send_msgs,"send_msgs");
            _ds.display(recv_msgs,"recv_msgs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(broker_id, true);
            _ds.displaySimple(user_online, true);
            _ds.displaySimple(send_msgs, true);
            _ds.displaySimple(recv_msgs, false);
            return _os;
        }
    public:
        std::string broker_id;
        tars::Int32 user_online;
        tars::Int32 send_msgs;
        tars::Int32 recv_msgs;
    };
    inline bool operator==(const MonitorResp&l, const MonitorResp&r)
    {
        return l.broker_id == r.broker_id && l.user_online == r.user_online && l.send_msgs == r.send_msgs && l.recv_msgs == r.recv_msgs;
    }
    inline bool operator!=(const MonitorResp&l, const MonitorResp&r)
    {
        return !(l == r);
    }


}



#endif
