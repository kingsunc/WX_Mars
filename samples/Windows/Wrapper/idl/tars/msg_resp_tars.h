// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __MESSAGESERVICE_H_
#define __MESSAGESERVICE_H_

#include <map>
#include <string>
#include <vector>
#include "tars/Tars.h"
using namespace std;


namespace MessageService
{
    enum GroupType
    {
        GroupTypeTeam = 0,
        GroupTypeMessage = 1,
    };
    inline string etos(const GroupType & e)
    {
        switch(e)
        {
            case GroupTypeTeam: return "GroupTypeTeam";
            case GroupTypeMessage: return "GroupTypeMessage";
            default: return "";
        }
    }
    inline int stoe(const string & s, GroupType & e)
    {
        if(s == "GroupTypeTeam")  { e=GroupTypeTeam; return 0;}
        if(s == "GroupTypeMessage")  { e=GroupTypeMessage; return 0;}

        return -1;
    }

    struct AppBaseInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.AppBaseInfo";
        }
        static string MD5()
        {
            return "325d87d477a8cf7a6468ed6bb39da964";
        }
        AppBaseInfo()
        :name(""),welcome("")
        {
        }
        void resetDefautlt()
        {
            name = "";
            welcome = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(name, 0);
            if (welcome != "")
            {
                _os.write(welcome, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(name, 0, true);
            _is.read(welcome, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(name,"name");
            _ds.display(welcome,"welcome");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(name, true);
            _ds.displaySimple(welcome, false);
            return _os;
        }
    public:
        std::string name;
        std::string welcome;
    };
    inline bool operator==(const AppBaseInfo&l, const AppBaseInfo&r)
    {
        return l.name == r.name && l.welcome == r.welcome;
    }
    inline bool operator!=(const AppBaseInfo&l, const AppBaseInfo&r)
    {
        return !(l == r);
    }

    struct AppInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.AppInfo";
        }
        static string MD5()
        {
            return "55b5da2a36fa6f2337b5eb8fa4d815d2";
        }
        AppInfo()
        :appId("")
        {
        }
        void resetDefautlt()
        {
            appId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(base, 0);
            _os.write(appId, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(base, 0, true);
            _is.read(appId, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(base,"base");
            _ds.display(appId,"appId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(base, true);
            _ds.displaySimple(appId, false);
            return _os;
        }
    public:
        MessageService::AppBaseInfo base;
        std::string appId;
    };
    inline bool operator==(const AppInfo&l, const AppInfo&r)
    {
        return l.base == r.base && l.appId == r.appId;
    }
    inline bool operator!=(const AppInfo&l, const AppInfo&r)
    {
        return !(l == r);
    }

    struct GroupBaseInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.GroupBaseInfo";
        }
        static string MD5()
        {
            return "6a4d92bed57348d3d74f1efed66849e2";
        }
        GroupBaseInfo()
        :type(MessageService::GroupTypeTeam),appId(""),groupId(""),name(""),desc(""),welcome(""),setting(0)
        {
        }
        void resetDefautlt()
        {
            appId = "";
            groupId = "";
            name = "";
            desc = "";
            welcome = "";
            setting = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write((tars::Int32)type, 0);
            if (appId != "")
            {
                _os.write(appId, 1);
            }
            _os.write(groupId, 2);
            _os.write(name, 3);
            if (desc != "")
            {
                _os.write(desc, 4);
            }
            if (welcome != "")
            {
                _os.write(welcome, 5);
            }
            if (setting != 0)
            {
                _os.write(setting, 6);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            tars::Int32 eTemp0 = MessageService::GroupTypeTeam;
            _is.read(eTemp0, 0, true);
            type = (MessageService::GroupType)eTemp0;
            _is.read(appId, 1, false);
            _is.read(groupId, 2, true);
            _is.read(name, 3, true);
            _is.read(desc, 4, false);
            _is.read(welcome, 5, false);
            _is.read(setting, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display((tars::Int32)type,"type");
            _ds.display(appId,"appId");
            _ds.display(groupId,"groupId");
            _ds.display(name,"name");
            _ds.display(desc,"desc");
            _ds.display(welcome,"welcome");
            _ds.display(setting,"setting");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple((tars::Int32)type, true);
            _ds.displaySimple(appId, true);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(name, true);
            _ds.displaySimple(desc, true);
            _ds.displaySimple(welcome, true);
            _ds.displaySimple(setting, false);
            return _os;
        }
    public:
        MessageService::GroupType type;
        std::string appId;
        std::string groupId;
        std::string name;
        std::string desc;
        std::string welcome;
        tars::Int64 setting;
    };
    inline bool operator==(const GroupBaseInfo&l, const GroupBaseInfo&r)
    {
        return l.type == r.type && l.appId == r.appId && l.groupId == r.groupId && l.name == r.name && l.desc == r.desc && l.welcome == r.welcome && l.setting == r.setting;
    }
    inline bool operator!=(const GroupBaseInfo&l, const GroupBaseInfo&r)
    {
        return !(l == r);
    }

    struct PSGroupInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.PSGroupInfo";
        }
        static string MD5()
        {
            return "30c96586005d02cb7abec84c48d2d1f8";
        }
        PSGroupInfo()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(base, 0);
            _os.write(users, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(base, 0, true);
            _is.read(users, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(base,"base");
            _ds.display(users,"users");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(base, true);
            _ds.displaySimple(users, false);
            return _os;
        }
    public:
        MessageService::GroupBaseInfo base;
        vector<std::string> users;
    };
    inline bool operator==(const PSGroupInfo&l, const PSGroupInfo&r)
    {
        return l.base == r.base && l.users == r.users;
    }
    inline bool operator!=(const PSGroupInfo&l, const PSGroupInfo&r)
    {
        return !(l == r);
    }

    struct CreateGroupReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.CreateGroupReq";
        }
        static string MD5()
        {
            return "88a84440e7401559489932d8bfbac5fd";
        }
        CreateGroupReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupInfo, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupInfo, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupInfo,"groupInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupInfo, false);
            return _os;
        }
    public:
        MessageService::GroupBaseInfo groupInfo;
    };
    inline bool operator==(const CreateGroupReq&l, const CreateGroupReq&r)
    {
        return l.groupInfo == r.groupInfo;
    }
    inline bool operator!=(const CreateGroupReq&l, const CreateGroupReq&r)
    {
        return !(l == r);
    }

    struct DeleteGroupReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.DeleteGroupReq";
        }
        static string MD5()
        {
            return "2e45701425f70f0e5c722cbe2c3f508e";
        }
        DeleteGroupReq()
        :groupId("")
        {
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, false);
            return _os;
        }
    public:
        std::string groupId;
    };
    inline bool operator==(const DeleteGroupReq&l, const DeleteGroupReq&r)
    {
        return l.groupId == r.groupId;
    }
    inline bool operator!=(const DeleteGroupReq&l, const DeleteGroupReq&r)
    {
        return !(l == r);
    }

    struct JoinGroupReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.JoinGroupReq";
        }
        static string MD5()
        {
            return "89945aac2d55c98d9c975caff4249a94";
        }
        JoinGroupReq()
        :groupId("")
        {
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(users, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(users, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(users,"users");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(users, false);
            return _os;
        }
    public:
        std::string groupId;
        vector<std::string> users;
    };
    inline bool operator==(const JoinGroupReq&l, const JoinGroupReq&r)
    {
        return l.groupId == r.groupId && l.users == r.users;
    }
    inline bool operator!=(const JoinGroupReq&l, const JoinGroupReq&r)
    {
        return !(l == r);
    }

    struct LeaveGroupReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.LeaveGroupReq";
        }
        static string MD5()
        {
            return "89945aac2d55c98d9c975caff4249a94";
        }
        LeaveGroupReq()
        :groupId("")
        {
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(users, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(users, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(users,"users");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(users, false);
            return _os;
        }
    public:
        std::string groupId;
        vector<std::string> users;
    };
    inline bool operator==(const LeaveGroupReq&l, const LeaveGroupReq&r)
    {
        return l.groupId == r.groupId && l.users == r.users;
    }
    inline bool operator!=(const LeaveGroupReq&l, const LeaveGroupReq&r)
    {
        return !(l == r);
    }

    struct AddSubgroupsReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.AddSubgroupsReq";
        }
        static string MD5()
        {
            return "89945aac2d55c98d9c975caff4249a94";
        }
        AddSubgroupsReq()
        :groupId("")
        {
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(subgroups, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(subgroups, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(subgroups,"subgroups");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(subgroups, false);
            return _os;
        }
    public:
        std::string groupId;
        vector<std::string> subgroups;
    };
    inline bool operator==(const AddSubgroupsReq&l, const AddSubgroupsReq&r)
    {
        return l.groupId == r.groupId && l.subgroups == r.subgroups;
    }
    inline bool operator!=(const AddSubgroupsReq&l, const AddSubgroupsReq&r)
    {
        return !(l == r);
    }

    struct DelSubgroupsReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.DelSubgroupsReq";
        }
        static string MD5()
        {
            return "89945aac2d55c98d9c975caff4249a94";
        }
        DelSubgroupsReq()
        :groupId("")
        {
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 0);
            _os.write(subgroups, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 0, true);
            _is.read(subgroups, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(subgroups,"subgroups");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(subgroups, false);
            return _os;
        }
    public:
        std::string groupId;
        vector<std::string> subgroups;
    };
    inline bool operator==(const DelSubgroupsReq&l, const DelSubgroupsReq&r)
    {
        return l.groupId == r.groupId && l.subgroups == r.subgroups;
    }
    inline bool operator!=(const DelSubgroupsReq&l, const DelSubgroupsReq&r)
    {
        return !(l == r);
    }

    struct DisturbReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.DisturbReq";
        }
        static string MD5()
        {
            return "951c383775fa91179e805999beb1591d";
        }
        DisturbReq()
        :nodisturbFlag(true)
        {
        }
        void resetDefautlt()
        {
            nodisturbFlag = true;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupIds, 0);
            if (nodisturbFlag != true)
            {
                _os.write(nodisturbFlag, 1);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupIds, 0, true);
            _is.read(nodisturbFlag, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupIds,"groupIds");
            _ds.display(nodisturbFlag,"nodisturbFlag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupIds, true);
            _ds.displaySimple(nodisturbFlag, false);
            return _os;
        }
    public:
        vector<std::string> groupIds;
        tars::Bool nodisturbFlag;
    };
    inline bool operator==(const DisturbReq&l, const DisturbReq&r)
    {
        return l.groupIds == r.groupIds && l.nodisturbFlag == r.nodisturbFlag;
    }
    inline bool operator!=(const DisturbReq&l, const DisturbReq&r)
    {
        return !(l == r);
    }

    struct SendMsgResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.SendMsgResp";
        }
        static string MD5()
        {
            return "c662d398ff0ef6ca06ffa3347ceca52c";
        }
        SendMsgResp()
        :msgId(0),timestamp(0),code(0),info("")
        {
        }
        void resetDefautlt()
        {
            msgId = 0;
            timestamp = 0;
            code = 0;
            info = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (msgId != 0)
            {
                _os.write(msgId, 0);
            }
            if (timestamp != 0)
            {
                _os.write(timestamp, 1);
            }
            if (code != 0)
            {
                _os.write(code, 2);
            }
            if (info != "")
            {
                _os.write(info, 3);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(msgId, 0, false);
            _is.read(timestamp, 1, false);
            _is.read(code, 2, false);
            _is.read(info, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(msgId,"msgId");
            _ds.display(timestamp,"timestamp");
            _ds.display(code,"code");
            _ds.display(info,"info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(msgId, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(code, true);
            _ds.displaySimple(info, false);
            return _os;
        }
    public:
        tars::Int64 msgId;
        tars::Int64 timestamp;
        tars::Short code;
        std::string info;
    };
    inline bool operator==(const SendMsgResp&l, const SendMsgResp&r)
    {
        return l.msgId == r.msgId && l.timestamp == r.timestamp && l.code == r.code && l.info == r.info;
    }
    inline bool operator!=(const SendMsgResp&l, const SendMsgResp&r)
    {
        return !(l == r);
    }

    struct Receipt : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.Receipt";
        }
        static string MD5()
        {
            return "89945aac2d55c98d9c975caff4249a94";
        }
        Receipt()
        :groupId("")
        {
        }
        void resetDefautlt()
        {
            groupId = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(groupId, 1);
            _os.write(subgroups, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(groupId, 1, true);
            _is.read(subgroups, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(groupId,"groupId");
            _ds.display(subgroups,"subgroups");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(groupId, true);
            _ds.displaySimple(subgroups, false);
            return _os;
        }
    public:
        std::string groupId;
        vector<std::string> subgroups;
    };
    inline bool operator==(const Receipt&l, const Receipt&r)
    {
        return l.groupId == r.groupId && l.subgroups == r.subgroups;
    }
    inline bool operator!=(const Receipt&l, const Receipt&r)
    {
        return !(l == r);
    }

}

#endif